<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chatbot</title>
  <style>
    body { margin: 0; font-family: sans-serif; }
    .chatbot-container {
      width: 100%;
      height: 400px;
      display: flex;
      flex-direction: column;
      border: 1px solid #ccc;
      box-sizing: border-box;
      font-size: 14px;
    }
    .chatbot-header {
      background: #004080;
      color: white;
      padding: 10px;
      text-align: center;
    }
    .chatbot-messages {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      background: #f9f9f9;
    }
    .chatbot-input {
      display: flex;
      border-top: 1px solid #ccc;
    }
    .chatbot-input input {
      flex: 1;
      border: none;
      padding: 10px;
      font-size: 14px;
    }
    .chatbot-input button {
      background: #004080;
      color: white;
      border: none;
      padding: 10px 15px;
      cursor: pointer;
    }
    .message {
      margin-bottom: 8px;
    }
    .message.user { text-align: right; color: #004080; }
    .message.assistant { text-align: left; color: black; }
  </style>
</head>
<body>
  <div class="chatbot-container">
    <div class="chatbot-header">Grace</div>
    <div class="chatbot-messages" id="messages"></div>
    <div class="chatbot-input">
      <input type="text" id="chat-input" placeholder="Type a message...">
      <button onclick="sendMessage()">Send</button>
    </div>
  </div>

  <script>
    let chatHistory = [];
    // let stepIndex = 0;
    let intent = null;
    let lastSelector = null;
    let botMessage = null;

    function appendMessage(role, text) {
      const messages = document.getElementById("messages");
      const div = document.createElement("div");
      div.className = "message " + role;
      div.innerText = text;
      messages.appendChild(div);
      messages.scrollTop = messages.scrollHeight;

      // Speak if the message is from assistant
      if (role === "assistant") {
        speak(text);
      }
    }
  
    // function highlight(selector) {
    //   if (!selector) return;
    //   console.log("selector highlighted", selector);
    //   window.parent.postMessage({ selector, instruction: "highlight" }, "*");
    // }

    function highlight(selector, lastInstruction = "mark-complete") {
      if (!selector) return;
      console.log("lastSelector and selector", lastSelector, selector);

      // Dehighlight the previous selector if it's different
      if (lastSelector && lastSelector !== selector) {
        console.log("dehighlighting in chatbot", lastSelector);
        window.parent.postMessage({selector: lastSelector, instruction: lastInstruction}, "*");
      }

      console.log("[Chatbot] Sending highlight to parent:", selector);
      // Highlight the new selector
      window.parent.postMessage({selector, instruction: "highlight"}, "*");
      lastSelector = selector; // Update the last selector
    }
    
  
    function logUserAction(text) {
      appendMessage("user", text);
      chatHistory.push({ role: "user", content: text });
      sessionStorage.setItem("chatHistory", JSON.stringify(chatHistory));
    }

    function updateSubstepFlagsForTransferSomeone() {
      const substep_flags = {};

      try {
        const parentDoc = window.parent.document;
        const account = parentDoc.querySelector("#from-account");
        const amount = parentDoc.querySelector("#amount");

        if (account && account.value !== "instruction") {
          substep_flags.account_chosen = true;
        }

        if (amount && parseFloat(amount.value) > 0) {
          substep_flags.amount_entered = true;
        }
      } catch (e) {
        console.warn("Unable to access parent form fields:", e);
      }

      return substep_flags;
    }

    async function speak(text) {
      try {
        const response = await fetch("/speak", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ text })
        });

        const result = await response.json();
        if (result.status === "success") {
          console.log("Speech played:", result.text);
        } else {
          console.error("TTS Error:", result.reason);
        }
      } catch (error) {
        console.error("Failed to fetch /speak:", error);
      }
    }

  
    // sendMessage() likely fires when: 
    // 1) The user types a message (e.g., "what's next?") 
    // 2) the page auto-resumes on load (newPageLoaded=True)
    async function sendMessage(newPageLoaded = false, substepUpdated = false) {
      console.log("sendMessage called", { newPageLoaded});
      const input = document.getElementById("chat-input");
      const message = newPageLoaded ? "resuming" : input.value.trim(); // Get user input or use overrideMessage if auto is true.
      if (!message && !newPageLoaded) return; // Don't send empty messages unless the page just loaded.
      const currentPage = window.parent.location.pathname.split("/").pop();
      
      let substep_flags = {};
      if (currentPage === "send_to_alex.html") {
        substep_flags = updateSubstepFlagsForTransferSomeone();
      }
  
      // Append the message to the chat history and display it
      if (!newPageLoaded) {
        appendMessage("user", message);
        chatHistory.push({ role: "user", content: message });
      }

      input.value = "";
  
      const res = await fetch("/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: chatHistory,
          newPageLoaded,
          substepUpdated,
          intent,
          currentPage,
          substep_flags  // âœ… Send subtask progress
        })
      });
  
      const data = await res.json();
      console.log("data from backend", data)
      console.log("flags", data.substep_flags);

      intent = data.intent
      selector = data.selector || null;
      botMessage = data.botMessage || "Hmmm not sure if I understand. Please tell me your goal.";
      
      appendMessage("assistant", botMessage);
      chatHistory.push({ role: "assistant", content: botMessage });
      sessionStorage.setItem("chatHistory", JSON.stringify(chatHistory));
  
      if (intent && intent !== "unknown") {
        sessionStorage.setItem("intent", intent);
      }
      
      if (selector) {
        sessionStorage.setItem("selector", selector);
        highlight(selector);
      }
    }
  
    // runs only once when chatbot.html is first rendered in the browser (i.e., when the iframe is inserted into the DOM and loads the chatbot page).
    window.addEventListener("DOMContentLoaded", () => {
      // Load chat history, intent
      console.log("DOMContentLoaded");  // ðŸ” baseline check
      chatHistory = JSON.parse(sessionStorage.getItem("chatHistory") || "[]");
      intent = sessionStorage.getItem("intent") || null;

      // Render chatbox and history
      for (const m of chatHistory) appendMessage(m.role, m.content); // Re-render chat history
      const input = document.getElementById("chat-input");
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") sendMessage();
      });

      // Automatically send a message: if there's no intent, asking for intent. If there's, resuming the conversation.
      if (!intent) {
        appendMessage("assistant", "Hi! I'm Grace, your banking assistant. How can I help you today?");
      } else {
        // Figure out the step based on intent + page
        // This logic is only run when the chatbot is first loaded, not on every message sent.
        // This is to ensure that the chatbot can resume the conversation from the correct step.
        console.log("calling sendMessage for resuming")
        sendMessage(newPageLoaded = true);
      }

      if (window.parent.location.pathname.endsWith("send_to_alex.html")) {
        const parentDoc = window.parent.document;
        console.log("parentDoc", parentDoc);

        parentDoc.querySelector("#from-account")?.addEventListener("change", () => {
          sendMessage(substepUpdated = true);
        });

        parentDoc.querySelector("#amount")?.addEventListener("input", () => {
          sendMessage(substepUpdated = true);
        });
      }
    });
  
    // This listens for messages from the parent window (the main app) to log user actions.
    window.addEventListener("message", (event) => {
      const { instruction, text } = event.data;
      if (instruction === "log" && typeof text === "string") {
        logUserAction(text);
      }
    });
  
    // This saves the chat history, step name, and intent to sessionStorage before the page is unloaded.
    window.addEventListener("beforeunload", () => {
      sessionStorage.setItem("chatHistory", JSON.stringify(chatHistory));
      sessionStorage.setItem("intent", intent);
    });
  </script>
  
  
</body>
</html>
